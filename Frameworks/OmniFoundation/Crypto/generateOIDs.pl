use strict;

my(%definitions, @emits, @lookups);

my($rcsid) = '$Id$';
my($cfilename) = 'out.c';
my($hfilename) = 'out.h';

if ($ENV{'SCRIPT_OUTPUT_FILE_COUNT'}) {
    my($n) = $ENV{'SCRIPT_OUTPUT_FILE_COUNT'};
    my($i);
    for($i = 0; $i < $n; $i ++) {
        my($fn) = $ENV{'SCRIPT_OUTPUT_FILE_' . $i};
        if ($fn =~ /\.h$/) {
            $hfilename = $fn;
        } elsif ($fn =~ /\.[cm]$/) {
            $cfilename = $fn;
        } else {
            warn "warning: unexpected input filename '$fn'\n";
        }
    }
} else {
    warn "No SCRIPT_OUTPUT_FILE_foo variables found\n";
}
print "C output file: $cfilename\n";
print "Header output file: $hfilename\n";

while(<DATA>) {
    chomp;
    s/\#.*$//;
    next if /^\s*$/;
    
    if (/^\s*(\S+)\s*\=\s*(\S.+\S)\s*$/) {
        my($name) = $1;
        my(@parts) = split(/\.|\s+/, $2);
        die "Duplicate definition for $name, died" if exists $definitions{$name};
        $definitions{$name} = \@parts;
    } elsif (/^emit\s+(.+)$/) {
        push(@emits, split(',', $1));
    } elsif (/^lookup\s+(.+)$/) {
        push(@lookups, $1);
    } else {
        die "Unexpected input line: $_\n";
    }
}

# Resolve a definition
my(%already);
sub resolve {
    my($name) = @_;
    die unless defined $name;
    return @{$already{$name}} if defined $already{$name};

    my(@resolved);
    foreach my $part (@{$definitions{$name}}) {
        if ($part =~ /^\d+$/) {
            push(@resolved, 0 + $part);
        } else {
            die "OID $name is defined in terms of $part, which isn't defined. Died" unless defined $definitions{$part};
            push(@resolved, &resolve($part));
        }
    }

    $already{$name} = \@resolved;

    @resolved;
}

sub matchnames {
    my($tbl, $pat, $as) = @_;

    if ($pat =~ /^([^*]+)\*([^*]*)/) {
        my($src) = '^' . quotemeta($1) . '(.+)' . quotemeta($2) . '$';
        die unless $as =~ /^([^*]*)\*([^*]*)/;
        my($lhs, $rhs) = ($1, $2);
        my(@found);
        foreach my $name (keys %$tbl) {
            if ($name =~ /$src/) {
                my($alias) = $lhs . $1 . $rhs;
                push(@found, [ $name, $alias ]);
            }
        }
        die "Pattern '$pat' doesn't match anything\n" unless @found;
        return @found;
    } else {
        die "No definition for '$pat'\n" unless defined $tbl->{$pat};
        return [ $pat, $as ];
    }
}

sub cmpoid {
    my($left, $right) = @_;
    my(@left) = &resolve($left);
    my(@right) = &resolve($right);

    die unless @left;
    die unless @right;
    
    while (@left && @right) {
        my($l) = shift @left;
        my($r) = shift @right;
        my($v) = $l <=> $r;
        return $v if $v;
    }

    return -1 if (@left);
    return 1 if @right;
    return 0;
}

# Process all 'emit' directives
my(%aliases);
foreach my $emit (@emits) {
    my($p) = $emit;
    my($pat, $as);
    if ($p =~ /^\s*(\S+)\s*$/) {
        $pat = $1;
        $as = $1;
    } elsif ($p =~ /^\s*(\S+)\s+as\s+(\S+)\s*$/) {
        $pat = $1;
        $as = $2;
    } else {
        die "Don't know what to do with: '$p'\n";
    }

    foreach my $match (&matchnames(\%definitions, $pat, $as)) {
        my($name, $alias) = @$match;
        die "multiple aliases for $name ?\n"
            if exists $aliases{$name} && ($aliases{$name} ne $alias);
        $aliases{$name} = $alias;
    }
}

my(%revaliases);
foreach my $name (keys %aliases) {
    my($alias) = $aliases{$name};
    die "Alias collision ($alias)? Died" if exists $revaliases{$alias};
    $revaliases{$alias} = $name;
}

# And 'lookup' directives
my(%lookups);
foreach my $lookup (@lookups) {
    $lookup =~ /^(\S+)\s+in\s+(\S+)\b(.*)$/
        or die "can't parse lookup directive: '$lookup'";

    my($pat, $tbl, $tail) = ($1, $2, $3);
    my($as) = $pat;

    if ($tail =~ /^\s*as\s+(\S+)((:?\s.*)?)$/) {
        $as = $1;
        $tail = $2;
    }

    if ($tail !~ /^\s*$/) {
        die "can't parse lookup directive: '$lookup' (tail $tail)";
    }

    foreach my $match (&matchnames(\%revaliases, $pat, $as)) {
        my($name, $alias) = @$match;

        $lookups{$tbl}->{$alias} = $name;
    }
}

# Write things out
open(CFILE, ">$cfilename") || die;
open(HFILE, ">$hfilename") || die;

my($banner) = "/* Generated by $0 on ".scalar(localtime())." */\n\n";
print HFILE $banner;
print CFILE $banner;
print CFILE <<"EOF";
#import <OmniBase/OmniBase.h>
#import <OmniFoundation/OFASN1Utilities.h>
#import <OmniFoundation/OFASN1-Internal.h>
#import \"$hfilename\"

RCS_ID(\"$rcsid\");

EOF

foreach my $emit (sort keys %aliases) {
    my(@nums) = &resolve($emit);
    my($alias) = $aliases{$emit};
    my($numstr) = join('.', @nums);
    my($cname) = $alias;
    $cname =~ s/-/_/g;
    
    die "OID values out of range ($emit = $numstr)\n" if $nums[0] > 6 || $nums[1] >= 40;

    my(@bytes) = ( ( $nums[0] * 40 ) + $nums[1] );
    shift @nums;
    shift @nums;
    foreach my $num (@nums) {
        my(@digits);
        while ($num > 127) {
            unshift(@digits, $num & 0x7F);
            $num = $num >> 7;
        }
        unshift(@digits, $num);
        while (@digits > 1) {
            push(@bytes, 0x80 + (shift @digits));
        }
        push(@bytes, @digits);
    }

    my($bytecount) = scalar(@bytes);
    my($bytestr) = join(', ', map { sprintf('0x%02X', $_) } (0x06, scalar(@bytes), @bytes) );

    print CFILE "\n/* $emit = $numstr */\n";
    print CFILE "const uint8_t der_".$cname."[".($bytecount + 2)."] = { $bytestr };\n";

    print HFILE "#define der_".$cname."_len ".($bytecount + 2)."\n";
    print HFILE "extern const uint8_t der_".$cname."[der_".$cname."_len] __attribute__((visibility(\"internal\")));\n";
    print HFILE "#define oid_".$cname."_len $bytecount\n";
    print HFILE "#define oid_$cname ( der_${cname} + 2 )\n";
}

print HFILE <<'EOF';

struct oid_lut_entry {
    int nid;
    const uint8_t *der;
    size_t der_len;
};
extern int _OFASN1LookUpOIDInTable(const uint8_t *, size_t, const struct oid_lut_entry *, int) __attribute__((visibility("internal")));

EOF

print CFILE <<'EOF';

int _OFASN1LookUpOIDInTable(const uint8_t *oid, size_t oidlen, const struct oid_lut_entry *lut, int lutsize)
{
    for(int i = 0; i < lutsize; i++) {
        if (oidlen == lut[i].der_len - 2 &&
            !memcmp(oid, lut[i].der + 2, oidlen)) {
            return lut[i].nid;
        }
    }

    return 0;
}

EOF

foreach my $lut (sort keys %lookups) {
    my($lu) = $lookups{$lut};
    my(@names) = keys %$lu;
    my($namecount) = scalar(@names);

    @names = sort { &cmpoid($revaliases{$lu->{$a}}, $revaliases{$lu->{$b}}) } @names;

    print CFILE "\nconst struct oid_lut_entry oid_lut_${lut}[$namecount] = {\n";
    print HFILE "\nenum ${lut};\n";
    foreach my $entry (@names) {
        my($dername) = $lu->{$entry};
        $dername =~ s/-/_/g;
        my($enumname) = $entry;
        $enumname =~ s/-/_/g;
        $enumname = $lut . '_' . $enumname;
        print CFILE "    { (int)$enumname, der_${dername}, der_${dername}_len },\n";
    }
    print CFILE "};\n";

    print HFILE "#define oid_lut_${lut}_size $namecount\n";
    print HFILE "extern const struct oid_lut_entry oid_lut_${lut}[oid_lut_${lut}_size] __attribute__((visibility(\"internal\")));\n";
    print HFILE "_Static_assert(${lut}_Unknown == 0, \"The 'Unknown' value of the ${lut} enum must be zero\");\n";
    print HFILE "#define ${lut}OIDTable oid_lut_${lut}, oid_lut_${lut}_size\n";
}

print HFILE "\n";
print HFILE "#define OFASN1LookUpOID(tp, ptr, len) ((enum tp)_OFASN1LookUpOIDInTable((ptr), (len), tp ## OIDTable))\n";

__DATA__

# Some useful prefixes
rsadsi = 1.2.840.113549
pkcs = rsadsi 1
csor = 2.16.840.1.101.3
certicom = 1.3.132
x9-57 = 1.2.840.10040
x9-62 = 1.2.840.10045
gnu = 1.3.6.1.4.1.11591
pgut = 1.3.6.1.4.1.3029
aes = csor 4 1

sha256 = csor 4 2 1
sha512 = csor 4 2 3
emit sha*

hmacWithSHA1   = rsadsi 2 7
hmacWithSHA256 = rsadsi 2 9
hmacWithSHA512 = rsadsi 2 11
emit hmacWith* as prf-hmacWith*
lookup prf-* in OFASN1Algorithm


aes128-cbc = aes 2
aes192-cbc = aes 22
aes256-cbc = aes 42

aes128-wrap = aes 5
aes192-wrap = aes 25
aes256-wrap = aes 45

aes128-gcm = aes 6
aes192-gcm = aes 26
aes256-gcm = aes 46

aes128-ccm = aes 7
aes192-ccm = aes 27
aes256-ccm = aes 47
emit aes* as alg-aes*

# From RFC6476
alg-authEnc-128 = pkcs 9 16 15
alg-authEnc-256 = pkcs 9 16 16

# From RFC3211
PBKDF2 = pkcs 5 12    # PKCS#5, RFC2898 [A.2], RFC3370 [4.4.1]
emit PBKDF2
lookup PBKDF2 in OFASN1Algorithm

# These algorithms are from RFC3211, but we never use them for generation.
# We include them so that we can test our parsing and higher-level code against sample data from the RFCs.
PWRI-KEK = pkcs 9 16 3 9
alg-des-ede-cbc = rsadsi 3 7
emit PWRI-KEK, alg-des-ede-cbc
lookup PWRI-KEK in OFASN1Algorithm

# Content types from RFC5652, RFC5911
ct-data = pkcs 7 1
ct-signedData = pkcs 7 2
ct-envelopedData = pkcs 7 3
ct-authenticatedData = pkcs 9 16 1 2
ct-compressedData = pkcs 9 16 1 9
ct-authenticatedEnvelopedData = pkcs 9 16 1 23
ct-XML = pkcs 9 16 1 28

# From RFC4073
ct-contentCollection = pkcs 9 16 1 19
ct-contentWithAttributes = pkcs 9 16 1 20

emit ct-*
lookup ct-* in OFCMSContentType as *

# Content attributes from RFC5652
attr-contentType = pkcs 9 3
attr-messageDigest = pkcs 9 4
attr-signingTime = pkcs 9 5
attr-contentIdentifier = pkcs 9 16 2 7
emit attr-*
lookup attr-* in OFCMSAttribute as *

alg-zlibCompress = pkcs 9 16 3 8
emit alg-zlibCompress

alg-rsaEncryption-pkcs1_5 = pkcs 1 1
emit alg-rsaEncryption-pkcs1_5

alg-ecPublicKey = x9-62 2 1
alg-ecDH = certicom 1 12
alg-DSA = x9-57 4 1
emit alg-DSA, alg-ecPublicKey, alg-ecDH

# RSAES-OAEP OIDs from RFC3560
alg-rsaEncryption_OAEP = pkcs 1 7
alg-mgf-1 = pkcs 1 8
oaep-pSpecified = pkcs 1 9
emit alg-rsaEncryption_OAEP, alg-mgf-1, oaep-pSpecified

lookup alg-* in OFASN1Algorithm as *

curve-secp192r1 = x9-62 3 1 1
curve-secp224r1 = certicom 0 33
curve-secp256r1 = x9-62 3 1 7
curve-secp384r1 = certicom 0 34
curve-secp521r1 = certicom 0 35

# These have been officially assigned by the owners of their parent
# arcs, but it's not clear they are the correct OIDs to use in a CMS context.
# curve-ed25519 = gnu 15 1
# curve-cv25519 = pgut 1 5 1
