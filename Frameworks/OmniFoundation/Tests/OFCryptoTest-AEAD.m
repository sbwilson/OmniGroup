// Copyright 2014,2016 Omni Development, Inc. All rights reserved.
//
// This software may only be used and reproduced according to the
// terms in the file OmniSourceLicense.html, which should be
// distributed with this project and can also be found at
// <http://www.omnigroup.com/developer/sourcecode/sourcelicense/>.


#import "OFCryptoTest.h"
#import "OFAEADCryptor.h"
#import <OmniBase/OmniBase.h>

RCS_ID("$Id$");

@implementation OFCryptoTests (AEAD)

#define COPYOUT(cursor) ^int(dispatch_data_t blk){ \
    size_t len = dispatch_data_get_size(blk); \
    [(NSData *)blk getBytes:cursor range:(NSRange){0, len}]; \
    cursor += len; \
    return 0; \
}

static BOOL rfc3610PacketVectorEncrypt(const uint8_t *key, const uint8_t *nonce, unsigned nonceLength, const uint8_t *input, unsigned inputLength, unsigned int aadLength, uint8_t *outputBuffer, unsigned int tagLength)
{
    CCCryptorStatus rc;
    OFAuthenticatedStreamEncryptorState est;
    
    CFDataRef aad = CFDataCreate(kCFAllocatorDefault, input, aadLength);
    
    rc = OFCCMBeginEncryption(key, 16, nonce, nonceLength,
                              inputLength - aadLength, tagLength, aad, &est);
    
    CFRelease(aad);
    
    if (rc != kCCSuccess)
        return NO;
    
    uint8_t * __block outputCursor = outputBuffer;
    
    rc = est->update(est, input + aadLength, inputLength - aadLength, COPYOUT(outputCursor));
    
    if (rc != kCCSuccess)
        return NO;
    
    assert(outputBuffer + (inputLength - aadLength) == outputCursor);

    rc = est->final(est, outputCursor, tagLength);
    
    if (rc != kCCSuccess)
        return NO;
    
    return YES;
}

static BOOL rfc3610PacketVectorDecrypt(const uint8_t *key, const uint8_t *nonce, unsigned nonceLength, const uint8_t *aadBytes, unsigned int aadLength, const uint8_t *ciphertext, unsigned int ciphertextLength, unsigned int tagLength, uint8_t *outputBuffer)
{
    CCCryptorStatus rc;
    OFAuthenticatedStreamDecryptorState dst;
    
    CFDataRef aad = CFDataCreate(kCFAllocatorDefault, aadBytes, aadLength);
    
    rc = OFCCMBeginDecryption(key, 16, nonce, nonceLength,
                              ciphertextLength, tagLength, aad, &dst);
    
    CFRelease(aad);
    
    if (rc != kCCSuccess)
        return NO;
    
    rc = dst->update(dst, ciphertext, ciphertextLength, outputBuffer);
    if (rc != kCCSuccess)
        return NO;
    
    rc = dst->final(dst, ciphertext + ciphertextLength, tagLength);
    if (rc != kCCSuccess)
        return NO;
    
    return YES;
}

#define NONCE(nm, ...) static const uint8_t nonce_ ## nm [] = { __VA_ARGS__ };
#define INPUT(nm, hdrLen, ...) static const uint8_t packet_ ## nm [] = { __VA_ARGS__ }; const unsigned packetPlaintextPortion_ ## nm = hdrLen;
#define ENCRYPTED(nm, ...) static const uint8_t expectedOutput_ ## nm [] = { __VA_ARGS__ };

#define CHECK_ENCRYPTED(nm, key) \
    uint8_t gotOutput_ ## nm [ sizeof(expectedOutput_ ## nm) ]; \
    memset(gotOutput_ ## nm, 0, sizeof(gotOutput_ ## nm)); \
    XCTAssert(rfc3610PacketVectorEncrypt(key, nonce_ ## nm, sizeof(nonce_ ## nm), packet_ ## nm, sizeof(packet_ ## nm), packetPlaintextPortion_ ## nm, gotOutput_ ## nm, sizeof(expectedOutput_ ## nm) + packetPlaintextPortion_ ## nm - sizeof(packet_ ## nm))); \
    OBAssertMemEqual(expectedOutput_ ## nm, gotOutput_ ## nm, sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm, \
              @"Encrypted output should match (%s)", #nm); \
    OBAssertMemEqual(expectedOutput_ ## nm + ( sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm ), gotOutput_ ## nm  + ( sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm ), sizeof(expectedOutput_ ## nm) - ( sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm ), \
              @"Authentication tag should match (%s)", #nm);

#define CHECK_DECRYPTED(nm, key) \
    uint8_t gotPlaintext_ ## nm [ sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm ]; \
    XCTAssert(rfc3610PacketVectorDecrypt(key, nonce_ ## nm, sizeof(nonce_ ## nm), packet_ ## nm, packetPlaintextPortion_ ## nm, expectedOutput_ ## nm, sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm, sizeof(expectedOutput_ ## nm) + packetPlaintextPortion_ ## nm - sizeof(packet_ ## nm), gotPlaintext_ ## nm)); \
    XCTAssert(memcmp(gotPlaintext_ ## nm, packet_ ## nm + packetPlaintextPortion_ ## nm, sizeof(packet_ ## nm) - packetPlaintextPortion_ ## nm) == 0, \
              @"Decrypted plaintext should match (%s)", #nm);

- (void)testRFC3610Vectors;
{
    static const uint8_t key1[16]  = { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                                       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF };
    static const uint8_t key13[16] = { 0xD7, 0x82, 0x8D, 0x13, 0xB2, 0xB0, 0xBD, 0xC3,
                                       0x25, 0xA7, 0x62, 0x36, 0xDF, 0x93, 0xCC, 0x6B };
    
    
    NONCE(Vector1, 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5);
    INPUT(Vector1, 8,
                   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                   0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                   0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E);
    ENCRYPTED(Vector1,
                   0x58, 0x8C, 0x97, 0x9A, 0x61, 0xC6, 0x63, 0xD2,
                   0xF0, 0x66, 0xD0, 0xC2, 0xC0, 0xF9, 0x89, 0x80,
                   0x6D, 0x5F, 0x6B, 0x61, 0xDA, 0xC3, 0x84, 0x17,
                   0xE8, 0xD1, 0x2C, 0xFD, 0xF9, 0x26, 0xE0);
    CHECK_ENCRYPTED(Vector1, key1);
    CHECK_DECRYPTED(Vector1, key1);
    
    NONCE(Vector2, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5);
    INPUT(Vector2, 8,
                   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                   0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                   0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F);
    ENCRYPTED(Vector2,
                   0x72, 0xC9, 0x1A, 0x36, 0xE1, 0x35, 0xF8, 0xCF,
                   0x29, 0x1C, 0xA8, 0x94, 0x08, 0x5C, 0x87, 0xE3,
                   0xCC, 0x15, 0xC4, 0x39, 0xC9, 0xE4, 0x3A, 0x3B,
                   0xA0, 0x91, 0xD5, 0x6E, 0x10, 0x40, 0x09, 0x16);
    CHECK_ENCRYPTED(Vector2, key1);
    CHECK_DECRYPTED(Vector2, key1);
    
    NONCE(Vector3, 0x00, 0x00, 0x00, 0x05, 0x04, 0x03, 0x02, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5);
    INPUT(Vector3, 8,
                   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                   0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                   0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
                   0x20);
    ENCRYPTED(Vector3,
                   0x51, 0xB1, 0xE5, 0xF4, 0x4A, 0x19, 0x7D, 0x1D,
                   0xA4, 0x6B, 0x0F, 0x8E, 0x2D, 0x28, 0x2A, 0xE8,
                   0x71, 0xE8, 0x38, 0xBB, 0x64, 0xDA, 0x85, 0x96,
                   0x57, 0x4A, 0xDA, 0xA7, 0x6F, 0xBD, 0x9F, 0xB0,
                   0xC5);
    CHECK_ENCRYPTED(Vector3, key1);
    CHECK_DECRYPTED(Vector3, key1);
    
    /* ... */
    
    NONCE(Vector22, 0x00, 0x5B, 0x8C, 0xCB, 0xCD, 0x9A, 0xF8, 0x3C, 0x96, 0x96, 0x76, 0x6C, 0xFA);
    INPUT(Vector22, 12,
                   0xEC, 0x46, 0xBB, 0x63, 0xB0, 0x25, 0x20, 0xC3,
                   0x3C, 0x49, 0xFD, 0x70, 0xB9, 0x6B, 0x49, 0xE2,
                   0x1D, 0x62, 0x17, 0x41, 0x63, 0x28, 0x75, 0xDB,
                   0x7F, 0x6C, 0x92, 0x43, 0xD2, 0xD7, 0xC2);
    ENCRYPTED(Vector22,
                   0x31, 0xD7, 0x50, 0xA0, 0x9D, 0xA3, 0xED, 0x7F,
                   0xDD, 0xD4, 0x9A, 0x20, 0x32, 0xAA, 0xBF, 0x17,
                   0xEC, 0x8E, 0xBF, 0x7D, 0x22, 0xC8, 0x08, 0x8C,
                   0x66, 0x6B, 0xE5, 0xC1, 0x97);
    CHECK_ENCRYPTED(Vector22, key13);
    CHECK_DECRYPTED(Vector22, key13);
    
    NONCE(Vector23, 0x00, 0x3E, 0xBE, 0x94, 0x04, 0x4B, 0x9A, 0x3C, 0x96, 0x96, 0x76, 0x6C, 0xFA);
    INPUT(Vector23, 12,
                   0x47, 0xA6, 0x5A, 0xC7, 0x8B, 0x3D, 0x59, 0x42,
                   0x27, 0xE8, 0x5E, 0x71, 0xE2, 0xFC, 0xFB, 0xB8,
                   0x80, 0x44, 0x2C, 0x73, 0x1B, 0xF9, 0x51, 0x67,
                   0xC8, 0xFF, 0xD7, 0x89, 0x5E, 0x33, 0x70, 0x76);
    ENCRYPTED(Vector23,
                   0xE8, 0x82, 0xF1, 0xDB, 0xD3, 0x8C, 0xE3, 0xED,
                   0xA7, 0xC2, 0x3F, 0x04, 0xDD, 0x65, 0x07, 0x1E,
                   0xB4, 0x13, 0x42, 0xAC, 0xDF, 0x7E, 0x00, 0xDC,
                   0xCE, 0xC7, 0xAE, 0x52, 0x98, 0x7D);
    CHECK_ENCRYPTED(Vector23, key13);
    CHECK_DECRYPTED(Vector23, key13);
    
    NONCE(Vector24, 0x00, 0x8D, 0x49, 0x3B, 0x30, 0xAE, 0x8B, 0x3C, 0x96, 0x96, 0x76, 0x6C, 0xFA);
    INPUT(Vector24, 12,
                   0x6E, 0x37, 0xA6, 0xEF, 0x54, 0x6D, 0x95, 0x5D,
                   0x34, 0xAB, 0x60, 0x59, 0xAB, 0xF2, 0x1C, 0x0B,
                   0x02, 0xFE, 0xB8, 0x8F, 0x85, 0x6D, 0xF4, 0xA3,
                   0x73, 0x81, 0xBC, 0xE3, 0xCC, 0x12, 0x85, 0x17,
                   0xD4);
    ENCRYPTED(Vector24,
                   0xF3, 0x29, 0x05, 0xB8, 0x8A, 0x64, 0x1B, 0x04,
                   0xB9, 0xC9, 0xFF, 0xB5, 0x8C, 0xC3, 0x90, 0x90,
                   0x0F, 0x3D, 0xA1, 0x2A, 0xB1, 0x6D, 0xCE, 0x9E,
                   0x82, 0xEF, 0xA1, 0x6D, 0xA6, 0x20, 0x59);
    CHECK_ENCRYPTED(Vector24, key13);
    CHECK_DECRYPTED(Vector24, key13);
}

// Test encrypting and decrypting with AAD of various lengths, to test the MAC-stream formatting and padding.
- (void)testCCMShortAAD;
{
    static const uint8_t key1[16]  = { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                                       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF };
    
    NONCE(Vector1, 0x76, 0x54, 0x32, 0x10, 0x02, 0x01, 0x00, 0xA0, 0xA1, 0xA2);
    
    const uint8_t input1[16] = { 0xB9, 0xC9, 0xFF, 0xB5, 0x8C, 0xC3, 0x90, 0x90,
                                 0x0F, 0x3D, 0xA1, 0x2A, 0xB1, 0x6D, 0xCE, 0x9E };

    const uint8_t aad[] = "The same thing we do every night";
    
    uint8_t tagBuffer[16];
    uint8_t ciphertextBuffer[32];
    uint8_t recoveredBuffer[32];
    
    for (size_t aadLength = 0; aadLength < sizeof(aad); aadLength ++) {
        
        CFDataRef aadData = CFDataCreate(kCFAllocatorDefault, aad, aadLength);
    
        for (unsigned int authTagLen = 4; authTagLen <= 16; authTagLen += 2) {
            
            {
                CCCryptorStatus rc;
                OFAuthenticatedStreamEncryptorState est;
                
                rc = OFCCMBeginEncryption(key1, sizeof(key1),
                                          nonce_Vector1, sizeof(nonce_Vector1),
                                          sizeof(input1),
                                          authTagLen, aadLength? aadData : NULL, &est);
                
                XCTAssertEqual(rc, kCCSuccess);
                if (rc != kCCSuccess)
                    return;
                
                uint8_t * __block outputCursor = ciphertextBuffer;
                
                rc = est->update(est, input1, sizeof(input1), COPYOUT(outputCursor));
                
                XCTAssertEqual(rc, kCCSuccess);
                
                assert(ciphertextBuffer + sizeof(input1) == outputCursor);
                
                rc = est->final(est, tagBuffer, authTagLen);
                
                XCTAssertEqual(rc, kCCSuccess);
            }
            
            {
                CCCryptorStatus rc;
                OFAuthenticatedStreamDecryptorState dst;
                
                rc = OFCCMBeginDecryption(key1, sizeof(key1),
                                          nonce_Vector1, sizeof(nonce_Vector1),
                                          sizeof(input1),
                                          authTagLen, aadData, &dst);
                XCTAssertEqual(rc, kCCSuccess);
                
                rc = dst->update(dst, ciphertextBuffer, sizeof(input1), recoveredBuffer);
                XCTAssertEqual(rc, kCCSuccess);
                
                rc = dst->final(dst, tagBuffer, authTagLen);
                XCTAssertEqual(rc, kCCSuccess);
            }
            
            OBAssertMemEqual(input1, recoveredBuffer, sizeof(input1));
        }
        
        CFRelease(aadData);
    }
}

// Test encrypting and decrypting with buffer boundaries at various locations.
- (void)testCCMBlockBoundaries;
{
    // Values from /dev/random
    static const uint8_t key[16]  = { 0xca, 0x18, 0x87, 0x8e, 0xba, 0xab, 0x8f, 0xc5, 0x3c, 0x27, 0x52, 0x1b, 0xb6, 0x7a, 0x86, 0x5d };
    static const uint8_t nonce[7] = { 0x92, 0x24, 0x3e, 0xed, 0xb8, 0x82, 0xa7 };
    static const uint8_t aad_bytes[30] = { 0x35, 0xa5, 0xa4, 0x13, 0x42, 0xce, 0x7b, 0x52, 0x1e, 0x28, 0xc0, 0xb2, 0xbe, 0x92, 0xac, 0x3c, 0x90, 0xb1, 0xe1, 0xaf, 0x50, 0x00, 0x70, 0xf1, 0xef, 0x3b, 0x48, 0xa6, 0x9c, 0x51 };
    
    size_t messageLen = 70000;
    uint8_t *plaintext = malloc(messageLen);
    uint8_t *ciphertext = malloc(messageLen);
    uint8_t *firstCiphertext = malloc(messageLen);
    uint8_t *decrypted = malloc(messageLen);
    CFDataRef aad = CFDataCreate(kCFAllocatorDefault, aad_bytes, sizeof(aad_bytes));
    
    // Fill the message buffer with known data
    for(unsigned i = 0; i < messageLen; i += 2) {
        OSWriteBigInt16(plaintext, i, i);
    }
    // Expected values. These were computed using Wei Dai's cryptopp version 5.6.5.
    static const uint8_t expected_icv[12] = {0xe3, 0x93, 0x83, 0x81, 0x53, 0xfd, 0xa0, 0xaa, 0xd9, 0x9c, 0x35, 0xf0};
    static const uint8_t expected_ciphertext_sha1[CC_SHA1_DIGEST_LENGTH] = {0x8C, 0x92, 0x6F, 0x45, 0xE8, 0x04, 0xAE, 0xC0, 0x29, 0x07, 0x68, 0x7A, 0x42, 0x21, 0x19, 0x4F, 0xB5, 0x44, 0xE0, 0xA8};
    
    for(int i = 0; i < 70; i++) {
        size_t splitPoint = ( i < 35? i+1 : messageLen - (70 - i));
        
        // NSLog(@"splitPoint=%zd  (buffers: 0x%zx and 0x%zx)", splitPoint, splitPoint, messageLen-splitPoint);
        
        {
            CCCryptorStatus rc;
            OFAuthenticatedStreamEncryptorState est;
            
            rc = OFCCMBeginEncryption(key, sizeof(key), nonce, sizeof(nonce), messageLen, sizeof(expected_icv), aad, &est);
            XCTAssertEqual(rc, kCCSuccess);
            if (rc != kCCSuccess)
                return;
            
            uint8_t * __block outputCursor = ciphertext;
            rc = est->update(est, plaintext, splitPoint, COPYOUT(outputCursor));
            XCTAssertEqual(rc, kCCSuccess);
            assert(ciphertext + splitPoint == outputCursor);
            rc = est->update(est, plaintext+splitPoint, messageLen-splitPoint, COPYOUT(outputCursor));
            XCTAssertEqual(rc, kCCSuccess);
            assert(ciphertext + messageLen == outputCursor);
            
            uint8_t tagBuffer[16];
            rc = est->final(est, tagBuffer, sizeof(expected_icv));
            XCTAssertEqual(rc, kCCSuccess);
            XCTAssert(!memcmp(tagBuffer, expected_icv, sizeof(expected_icv)));
            
            if (i == 0) {
                // Our first ciphertext.
                memcpy(firstCiphertext, ciphertext, messageLen);
                
                uint8_t checksum_buf[CC_SHA1_DIGEST_LENGTH];
                CC_SHA1(ciphertext, (CC_LONG)messageLen, checksum_buf);
                XCTAssert(!memcmp(checksum_buf, expected_ciphertext_sha1, CC_SHA1_DIGEST_LENGTH));
            } else {
                XCTAssert(!memcmp(firstCiphertext, ciphertext, messageLen));
            }
        }
        
        
        {
            CCCryptorStatus rc;
            OFAuthenticatedStreamDecryptorState dst;
            
            rc = OFCCMBeginDecryption(key, sizeof(key), nonce, sizeof(nonce), messageLen, sizeof(expected_icv), aad, &dst);
            XCTAssertEqual(rc, kCCSuccess);
            
            rc = dst->update(dst, ciphertext, splitPoint, decrypted);
            XCTAssertEqual(rc, kCCSuccess);
            rc = dst->update(dst, ciphertext+splitPoint, messageLen-splitPoint, decrypted+splitPoint);
            XCTAssertEqual(rc, kCCSuccess);
            
            rc = dst->final(dst, expected_icv, sizeof(expected_icv));
            XCTAssertEqual(rc, kCCSuccess);
            
            XCTAssert(!memcmp(plaintext, decrypted, messageLen));
        }
    }
    
    CFRelease(aad);
}

#undef INPUT
#undef CHECK_ENCRYPTED
#undef CHECK_DECRYPTED

#ifdef OF_AEAD_GCM_ENABLED

static BOOL AESGCMEncrypt(const uint8_t *key, unsigned int keyLength,
                          const uint8_t *nonce, unsigned nonceLength,
                          const uint8_t *input, unsigned inputLength,
                          const uint8_t *aadBytes, unsigned int aadLength,
                          uint8_t *outputBuffer, unsigned int tagLength)
{
    CCCryptorStatus rc;
    OFAuthenticatedStreamEncryptorState est;
    
    CFDataRef aad = CFDataCreate(kCFAllocatorDefault, aadBytes, aadLength);
    
    rc = OFGCMBeginEncryption(key, keyLength, nonce, nonceLength, aad, &est);
    
    CFRelease(aad);
    
    uint8_t * __block outputCursor = outputBuffer;
    
    rc = est->update(est, input, inputLength, COPYOUT(outputCursor));
    
    assert(outputCursor == outputBuffer + inputLength);
    
    rc = est->final(est, outputCursor, tagLength);
    
    return YES;
}

static BOOL AESGCMDecrypt(const uint8_t *key, unsigned int keyLength,
                          const uint8_t *nonce, unsigned nonceLength,
                          const uint8_t *input, unsigned inputLength,
                          const uint8_t *aadBytes, unsigned int aadLength,
                          const uint8_t *tag, unsigned int tagLength,
                          uint8_t *outputBuffer)
{
    CCCryptorStatus rc;
    OFAuthenticatedStreamDecryptorState dst;
    
    CFDataRef aad = CFDataCreate(kCFAllocatorDefault, aadBytes, aadLength);
    
    rc = OFGCMBeginDecryption(key, keyLength, nonce, nonceLength, aad, &dst);
    
    CFRelease(aad);
    
    rc = dst->update(dst, input, inputLength, outputBuffer);
    
    rc = dst->final(dst, tag, tagLength);
    
    return YES;
}



#define AAD(nm, ...) static const uint8_t additionalAuthenticatedData_ ## nm [] = { __VA_ARGS__ };
#define INPUT(nm, ...) static const uint8_t input_ ## nm [] = { __VA_ARGS__ };
#define TAG(nm, ...) static const uint8_t expectedAuthTag_ ## nm [] = { __VA_ARGS__ };

#define CHECK_ENCRYPTED(nm, key) \
    uint8_t outputBuffer_ ## nm [ sizeof(input_ ## nm) + sizeof(expectedAuthTag_ ## nm) ]; \
    XCTAssert(AESGCMEncrypt(key, sizeof(key), nonce_ ## nm, sizeof(nonce_ ## nm), input_ ## nm, sizeof(input_ ## nm), additionalAuthenticatedData_ ## nm, sizeof(additionalAuthenticatedData_ ## nm), outputBuffer_ ## nm, sizeof(expectedAuthTag_ ## nm))); \
    XCTAssert(memcmp(outputBuffer_ ## nm, expectedOutput_ ## nm, sizeof(input_ ## nm)) == 0, \
        @"Encrypted output should match (%s)", #nm); \
    XCTAssert(memcmp(outputBuffer_ ## nm + sizeof(input_ ## nm), expectedAuthTag_ ## nm, sizeof(expectedAuthTag_ ## nm)) == 0, \
        @"Generated auth tag should match (%s)", #nm);

#define CHECK_DECRYPTED(nm, key) \
    uint8_t gotPlaintext_ ## nm [ sizeof(input_ ## nm) ]; \
    XCTAssert(AESGCMDecrypt(key, sizeof(key), nonce_ ## nm, sizeof(nonce_ ## nm), expectedOutput_ ## nm, sizeof(expectedOutput_ ## nm), additionalAuthenticatedData_ ## nm, sizeof(additionalAuthenticatedData_ ## nm), expectedAuthTag_ ## nm, sizeof(expectedAuthTag_ ## nm), gotPlaintext_ ## nm)); \
    XCTAssert(memcmp(gotPlaintext_ ## nm, input_ ## nm, sizeof(input_ ## nm)) == 0, \
        @"Decrypted plaintext should match (%s)", #nm);


// These are the test vectors from "The Galois/Counter Mode of Operation (GCM)", David A. McGrew & John Viega, <http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf>
- (void)testMcGrewViega;
{
    static const uint8_t key1[16]  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    static const uint8_t key3[16]  = { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                       0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 };
    static const uint8_t key7[24]  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    static const uint8_t key9[24]  = { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                       0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
                                       0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c };
    static const uint8_t key15[32] = { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                       0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
                                       0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                       0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 };
    
    AAD(TestCase1);
    INPUT(TestCase1);
    NONCE(TestCase1,      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    ENCRYPTED(TestCase1);
    TAG(TestCase1,        0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61, 0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a);
    CHECK_ENCRYPTED(TestCase1, key1);
    CHECK_DECRYPTED(TestCase1, key1);

    AAD(TestCase2);
    INPUT(TestCase2,      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    NONCE(TestCase2,      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    ENCRYPTED(TestCase2,  0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78);
    TAG(TestCase2,        0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd, 0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf);
    CHECK_ENCRYPTED(TestCase2, key1);
    CHECK_DECRYPTED(TestCase2, key1);
    
    AAD(TestCase3);
    INPUT(TestCase3,      0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55);
    NONCE(TestCase3,      0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88);
    ENCRYPTED(TestCase3,  0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
                          0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
                          0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
                          0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85);
    TAG(TestCase3,        0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6, 0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4);
    CHECK_ENCRYPTED(TestCase3, key3);
    CHECK_DECRYPTED(TestCase3, key3);

    AAD(TestCase4,        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
                          0xab, 0xad, 0xda, 0xd2);
    INPUT(TestCase4,      0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39);
    NONCE(TestCase4,      0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88);
    ENCRYPTED(TestCase4,  0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
                          0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
                          0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
                          0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91);
    TAG(TestCase4,        0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb, 0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47);
    CHECK_ENCRYPTED(TestCase4, key3);
    CHECK_DECRYPTED(TestCase4, key3);
    
    AAD(TestCase5,        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
                          0xab, 0xad, 0xda, 0xd2);
    INPUT(TestCase5,      0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39);
    NONCE(TestCase5,      0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad);
    ENCRYPTED(TestCase5,  0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a, 0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55,
                          0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8, 0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23,
                          0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2, 0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42,
                          0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07, 0xc2, 0x3f, 0x45, 0x98);
    TAG(TestCase5,        0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85, 0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb);
    CHECK_ENCRYPTED(TestCase5, key3);
    CHECK_DECRYPTED(TestCase5, key3);
    
    AAD(TestCase6,        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
                          0xab, 0xad, 0xda, 0xd2);
    INPUT(TestCase6,      0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39);
    NONCE(TestCase6,      0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
                          0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
                          0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
                          0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b);
    ENCRYPTED(TestCase6,  0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6, 0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94,
                          0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8, 0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7,
                          0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90, 0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f,
                          0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03, 0x4c, 0x34, 0xae, 0xe5);
    TAG(TestCase6,        0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa, 0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50);
    CHECK_ENCRYPTED(TestCase6, key3);
    CHECK_DECRYPTED(TestCase6, key3);
    
    AAD(TestCase7);
    INPUT(TestCase7);
    NONCE(TestCase7,      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    ENCRYPTED(TestCase7);
    TAG(TestCase7,        0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b, 0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35);
    CHECK_ENCRYPTED(TestCase7, key7);
    CHECK_DECRYPTED(TestCase7, key7);

    /* ... */
    
    AAD(TestCase9);
    INPUT(TestCase9,      0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55);
    NONCE(TestCase9,      0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88);
    ENCRYPTED(TestCase9,  0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,
                          0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,
                          0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,
                          0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56);
    TAG(TestCase9,        0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf, 0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14);
    CHECK_ENCRYPTED(TestCase9, key9);
    CHECK_DECRYPTED(TestCase9, key9);
    
    /* ... */
    
    AAD(TestCase15);
    INPUT(TestCase15,     0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55);
    NONCE(TestCase15,     0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88);
    ENCRYPTED(TestCase15, 0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,
                          0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,
                          0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,
                          0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad);
    TAG(TestCase15,       0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd, 0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c);
    CHECK_ENCRYPTED(TestCase15, key15);
    CHECK_DECRYPTED(TestCase15, key15);
    
    /* ... */
    
    AAD(TestCase17,       0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
                          0xab, 0xad, 0xda, 0xd2);
    INPUT(TestCase17,     0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
                          0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
                          0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                          0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39);
    NONCE(TestCase17,     0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad);
    ENCRYPTED(TestCase17, 0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32, 0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb,
                          0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa, 0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0,
                          0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0, 0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78,
                          0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99, 0xf4, 0x7c, 0x9b, 0x1f);
    TAG(TestCase17,       0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4, 0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2);
    CHECK_ENCRYPTED(TestCase17, key15);
    CHECK_DECRYPTED(TestCase17, key15);

}

#endif

@end
